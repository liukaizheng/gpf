use core::panic;
use std::{alloc::Allocator, ops::Deref};

use bumpalo::Bump;
use std::collections::{HashMap, HashSet};
use itertools::Itertools;

use crate::{
    disjoint_set::DisjointSet,
    graphcut::GraphCut,
    math::{cross, norm, sub},
    mesh::{EdgeId, ElementId, Face, FaceId, Halfedge, HalfedgeId, Mesh, SurfaceMesh, VertexId},
    predicates::{
        double_to_sign, max_comp_in_tri_normal, orient2d, orient2d_by_axis, orient3d::orient3d,
        sign_reversed, ExplicitPoint3D, ImplicitPoint3D, ImplicitPointLPI, ImplicitPointTPI,
        Orientation, Point3D,
    },
    triangle::{triangulate, TetMesh},
    INVALID_IND,
};

use super::{conforming_mesh::Constraints, point};

struct EdgeGroup {
    edges: Vec<(EdgeId, bool)>,
}

impl EdgeGroup {
    #[inline(always)]
    fn new(edges: Vec<(EdgeId, bool)>) -> Self {
        Self { edges }
    }

    #[inline(always)]
    fn position(&self, eid: EdgeId) -> usize {
        self.edges.iter().rposition(|he| he.0 == eid).unwrap()
    }
}

#[derive(Clone)]
struct BSPVertexData {
    parent: [VertexId; 2],
}

impl BSPVertexData {
    fn new(vid: VertexId) -> Self {
        Self { parent: [vid, vid] }
    }
}

#[derive(Clone)]
struct BSPEdgeData {
    /// If edge originates from two vertices, it's parents are exactly these two vertices;
    /// If edge generated by two planes intersecting, it's parents are six vertices of two plane.
    parents: Vec<VertexId>,
    // the id of it's original edge
    id: usize,
}

impl BSPEdgeData {
    fn new(parents: Vec<VertexId>, id: usize) -> Self {
        Self { parents, id }
    }
}

#[derive(Clone)]
struct BSPFaceData {
    cells: [usize; 2],
    // coplanar triangles
    triangles: Vec<usize>,
    plane: [VertexId; 3],
    id: usize,
}

impl BSPFaceData {
    fn new(c1: usize, c2: usize, triangles: Vec<usize>, plane: [VertexId; 3], id: usize) -> Self {
        Self {
            cells: [c1, c2],
            triangles,
            plane,
            id,
        }
    }
}

#[derive(Clone)]
struct BSPCellData {
    faces: Vec<FaceId>,
    inner_triangles: Vec<usize>,
}

impl BSPCellData {
    fn new(faces: Vec<FaceId>, inner_triangles: Vec<usize>) -> Self {
        Self {
            faces,
            inner_triangles,
        }
    }
}

pub(crate) struct BSPComplex {
    points: Vec<Point3D>,
    pub mesh: SurfaceMesh,
    vertex_data: Vec<BSPVertexData>,
    edge_data: Vec<BSPEdgeData>,
    face_data: Vec<BSPFaceData>,
    cell_data: Vec<BSPCellData>,
    constraints: Vec<VertexId>,
    n_ori_triangles: usize,

    vert_orientations: Vec<HashMap<VertexId, Orientation>>,
    vert_visits: Vec<bool>,

    edge_visits: Vec<bool>,

    tri_orientations: Vec<usize>,
}

#[inline(always)]
fn tet_face_is_new(tid: usize, adj_tid: usize, adj_cid: usize) -> bool {
    adj_tid > tid || adj_cid == INVALID_IND
}

impl BSPComplex {
    pub(crate) fn new(
        tet_mesh: TetMesh,
        constraints_data: &Constraints,
        tet_mark: [Vec<Vec<usize>>; 5],
    ) -> Self {
        let points = Vec::from_iter(
            tet_mesh
                .points
                .chunks(3)
                .map(|data| Point3D::Explicit(ExplicitPoint3D::from(data))),
        );

        let new_tet_orders = remove_ghost_tets(&tet_mesh);
        let mut face_positions = vec![INVALID_IND; tet_mesh.tets.len() << 2];
        let mut faces: Vec<Vec<usize>> = Vec::new();
        let mut face_data: Vec<BSPFaceData> = Vec::new();
        let mut cell_data: Vec<BSPCellData> = Vec::new();
        let mut bump = Bump::new();
        for (tid, tet) in tet_mesh.tets.iter().enumerate() {
            let cell_idx = new_tet_orders[tid];
            if cell_idx == INVALID_IND {
                continue;
            }

            let mut cell_faces = Vec::new();
            for (i, nei) in tet.nei.iter().enumerate() {
                let adj_cell_idx = new_tet_orders[nei.tet];
                if tet_face_is_new(tid, nei.tet, adj_cell_idx) {
                    let tri = [tet_mesh.org(nei), tet_mesh.apex(nei), tet_mesh.dest(nei)];
                    let mut face = BSPFaceData::new(
                        cell_idx,
                        adj_cell_idx,
                        Vec::new(),
                        tri.map(|vid| vid.into()),
                        face_data.len(),
                    );
                    faces.push(tri.to_vec());
                    insert_coplanar_triangles(
                        &tet_mark[i][tid],
                        &mut face.triangles,
                        constraints_data.n_ori_triangles,
                    );
                    let fid = face_data.len();
                    face_positions[(tid << 2) + i] = fid;
                    cell_faces.push(fid.into());
                    face_data.push(face);
                } else {
                    let j = nei.ver & 3;
                    let fid = face_positions[(nei.tet << 2) + j];
                    let face = &mut face_data[fid];
                    insert_coplanar_triangles(
                        &tet_mark[j][nei.tet],
                        &mut face.triangles,
                        constraints_data.n_ori_triangles,
                    );
                    cell_faces.push(fid.into());
                }
            }
            cell_data.push(BSPCellData::new(cell_faces, tet_mark[4][tid].clone()));
        }

        let mesh = SurfaceMesh::from(faces);

        let vert_orientations = vec![HashMap::new(); constraints_data.triangles.len() / 3];
        let vert_visits = vec![false; points.len()];
        let vertex_data = Vec::from_iter(mesh.vertices().map(|vid| BSPVertexData::new(vid)));

        let edge_visits = vec![false; mesh.n_edges()];
        let edge_data = Vec::from_iter(
            mesh.edges()
                .enumerate()
                .map(|(i, eid)| BSPEdgeData::new(Vec::from_iter(mesh.e_vertices(eid)), i)),
        );

        let constraints = Vec::from_iter(constraints_data.triangles.iter().map(|&idx| idx.into()));
        let tri_orientations = Vec::from_iter(constraints_data.triangles.chunks(3).map(|tri| {
            bump.reset();
            let tri_points = Vec::from_iter(tri.iter().map(|&vid| point(tet_mesh.points, vid)));
            max_comp_in_tri_normal(tri_points[0], tri_points[1], tri_points[2], &bump)
        }));

        Self {
            points,
            mesh,
            vertex_data,
            edge_data,
            face_data,
            cell_data,
            constraints,
            n_ori_triangles: constraints_data.n_ori_triangles,
            edge_visits,
            vert_orientations,
            vert_visits,

            tri_orientations,
        }
    }

    #[inline(always)]
    pub(crate) fn n_cells(&self) -> usize {
        self.cell_data.len()
    }

    #[inline(always)]
    pub(crate) fn splittable(&self, cid: usize) -> bool {
        !self.cell_data[cid].inner_triangles.is_empty()
    }

    pub(crate) fn split_cell<A: Allocator + Copy>(&mut self, cid: usize, bump: A) {
        let tid = *self.cell_data[cid].inner_triangles.last().unwrap();
        let tri = self.triangle(tid).to_vec_in(bump);
        self.cell_data[cid].inner_triangles.pop();
        let mut coplanar_triangles = self.separate_out_coplanar_triangles(tid, cid, bump);
        if !self.is_virtual(tid) {
            coplanar_triangles.push(tid);
        }
        let (cell_verts, cell_edges) = self.cell_verts_and_edges(cid, bump);
        verts_orient_wrt_plane(
            &self.points[tri[0]],
            &self.points[tri[1]],
            &self.points[tri[2]],
            &cell_verts,
            &self.points,
            &self.vertex_data,
            &mut self.vert_orientations[tid],
            bump,
        );

        let mut pos_verts = Vec::new();
        let mut neg_verts = Vec::new();
        for vid in &cell_verts {
            match self.vert_orientations[tid].get(vid).unwrap() {
                Orientation::Positive => {
                    pos_verts.push(*vid);
                }
                Orientation::Negative => {
                    neg_verts.push(*vid);
                }
                _ => {}
            }
        }
        if pos_verts.len() == 0 || neg_verts.len() == 0 {
            panic!("don't find plane to split cell");
        }

        let mut new_pts: Vec<Point3D> = Vec::new();
        let mut ef_clip_pt_map: HashMap<EdgeId, usize> = HashMap::new(); // map from edge to it's intersection point with triangle
        let mut intersect_edges = Vec::new();

        for &eid in &cell_edges {
            let eid = eid.into();
            let e_verts = self.mesh.e_vertices(eid);
            let e_vert_oris = e_verts.map(|vid| *self.vert_orientations[tid].get(&vid).unwrap());
            if sign_reversed(e_vert_oris[0], e_vert_oris[1]) {
                ef_clip_pt_map.insert(eid, new_pts.len());
                new_pts.push(self.get_ef_clip_pt(eid, &tri, bump));
                intersect_edges.push(eid);
            }
        }

        let mut pos_faces = Vec::new(); // cell pos faces
        let mut neg_faces = Vec::new(); // cell neg faces
        let zero_outlines = make_loop1(
            &self.mesh,
            self.cell_data[cid]
                .faces
                .iter()
                .map(|&fid| {
                    (
                        fid,
                        split_face_verts1(&self.mesh, fid, &self.vert_orientations[tid]),
                    )
                })
                .filter_map(|(fid, split)| match split {
                    SplitFaceResult::IsPos(is_pos) => {
                        if is_pos {
                            pos_faces.push(fid);
                        } else {
                            neg_faces.push(fid);
                        }
                        None
                    }
                    _ => Some(split),
                })
                .collect_vec(),
            &ef_clip_pt_map,
        );

        {
            // check if triangle intersects with the intersection by triangle plane and cell
            let intersect_poly = zero_outlines
                .iter()
                .map(|split| match split.start(&self.mesh, &ef_clip_pt_map) {
                    GeneralVertexId::Vertex(vid) => &self.points[vid],
                    GeneralVertexId::Index(idx) => &new_pts[idx],
                })
                .collect_vec();
            let tri_pts = tri.iter().map(|&vid| &self.points[vid]).collect_vec();
            if !is_triangle_intersects_poly(
                &tri_pts,
                &intersect_poly,
                self.tri_orientations[tid],
                bump,
            ) {
                return;
            }
        }

        // split edges
        let mut new_vertices = Vec::new();
        for (eid, pt) in intersect_edges.into_iter().zip(new_pts) {
            let e_verts = self.mesh.e_vertices(eid);
            let vid = self.mesh.split_edge(eid, bump);

            self.points.push(pt);

            self.vert_visits.push(false);
            self.vert_orientations[tid].insert(vid, Orientation::Zero);
            self.vertex_data.push(BSPVertexData{ parent: e_verts });

            self.edge_visits.push(false);
            self.edge_data.push(BSPEdgeData::new(self.edge_data[eid].parents.clone(), self.edge_data.len()));

            new_vertices.push(vid);
        }

        // split faces
        let mut zero_ori_halfedges = Vec::new();
        let orientation = &mut self.vert_orientations[tid];
        for split in zero_outlines {
            match split {
                SplitFaceResult::TwoVerts(two_verts) => {
                    let fid = self.mesh.he_face(two_verts[0].unwrap_halfedge());
                    let [va, vb] = two_verts.map(|v| {
                        match v.id(&self.mesh, &ef_clip_pt_map) {
                            GeneralVertexId::Vertex(vid) => vid,
                            GeneralVertexId::Index(idx) => new_vertices[idx],
                        }
                    });
                    let new_hid = self.mesh.split_face(fid, va, vb, bump);
                    let new_fid = self.mesh.he_face(new_hid);
                    let new_is_pos = self.mesh.he_vertex(new_hid) == va;
                    if new_is_pos {
                        zero_ori_halfedges.push(new_hid);
                        pos_faces.push(new_fid);
                        neg_faces.push(fid);
                    } else {
                        zero_ori_halfedges.push(self.mesh.he_sibling(new_hid));
                        pos_faces.push(fid);
                        neg_faces.push(new_fid);
                    }

                    self.edge_visits.push(false);
                    let parent = Vec::from_iter(tri.iter().chain(&self.face_data[fid].plane).map(|id| *id));
                    self.edge_data
                        .push(BSPEdgeData::new(parent, self.edge_data.len()));

                    for &nei_cid in &self.face_data[fid].cells {
                        if nei_cid != INVALID_IND && nei_cid != cid {
                            self.cell_data[nei_cid].faces.push(new_fid);
                        }
                    }

                    let mut new_face_triangles = Vec::new();
                    self.face_data[fid].triangles.retain(|&face_tid| {
                        let face_tri = {
                            let start = face_tid * 3;
                            &self.constraints[start..(start + 3)]
                        };
                        verts_orient_wrt_plane(
                            &self.points[tri[0]],
                            &self.points[tri[1]],
                            &self.points[tri[2]],
                            face_tri,
                            &self.points,
                            &self.vertex_data,
                            orientation,
                            bump,
                        );
                        let (mut has_pos, mut has_neg) = (false, false);
                        for vid in face_tri {
                            match orientation.get(vid).unwrap() {
                                Orientation::Positive => {
                                    has_pos = true;
                                }
                                Orientation::Negative => {
                                    has_neg = true;
                                }
                                _ => {}
                            }
                        }
                        if new_is_pos {
                            if has_pos {
                                new_face_triangles.push(face_tid);
                            }
                        } else {
                            if has_neg {
                                new_face_triangles.push(face_tid);
                            }
                        }
                        if !new_is_pos {
                            has_pos
                        } else {
                            has_neg
                        }
                    });
                    let old_face_data = &self.face_data[fid];
                    self.face_data.push(BSPFaceData {
                        cells: old_face_data.cells,
                        triangles: new_face_triangles,
                        plane: old_face_data.plane,
                        id: old_face_data.id,
                    });
                }

                SplitFaceResult::ZeroHalfedges(halfedges) => {
                    zero_ori_halfedges.extend(halfedges);
                }
                _ => {}
            }
        }

        // add separating face
        {
            let face_halfedges = make_loop(&self.mesh, zero_ori_halfedges);
            let new_fid = self.mesh.add_face_by_halfedges(&face_halfedges, bump);
            for vid in self
                .mesh
                .face(new_fid)
                .halfedges()
                .map(|hid| self.mesh.he_vertex(hid))
            {
                pos_verts.push(vid);
                neg_verts.push(vid);
            }

            let new_cid = self.cell_data.len();
            self.face_data.push(BSPFaceData::new(
                new_cid,
                cid,
                coplanar_triangles,
                [tri[0], tri[1], tri[2]],
                new_fid.0,
            ));

            for &fid in &pos_faces {
                for f_cid in &mut self.face_data[fid].cells {
                    if *f_cid == cid {
                        *f_cid = new_cid;
                    }
                }
            }

            pos_faces.push(new_fid);
            neg_faces.push(new_fid);
            self.cell_data[cid].faces = neg_faces;

            self.cell_data.push(BSPCellData::new(pos_faces, Vec::new()));

            let mut pos_inner_triangles = Vec::new();
            let mut neg_inner_triangles = Vec::new();

            for &inner_tid in &self.cell_data[cid].inner_triangles {
                let inner_tri = triangle(inner_tid, &self.constraints);
                if is_triangle_intersects_cell(
                    new_cid,
                    inner_tri,
                    &pos_verts,
                    &self.cell_data[new_cid].faces,
                    &self.points,
                    &self.vertex_data,
                    &self.face_data,
                    &mut self.vert_orientations[inner_tid],
                    bump,
                ) {
                    pos_inner_triangles.push(inner_tid);
                }

                if is_triangle_intersects_cell(
                    cid,
                    inner_tri,
                    &neg_verts,
                    &self.cell_data[cid].faces,
                    &self.points,
                    &self.vertex_data,
                    &self.face_data,
                    &mut self.vert_orientations[inner_tid],
                    bump,
                ) {
                    neg_inner_triangles.push(inner_tid);
                }

                /*if not_a && not_b {
                    println!("cid: {}, tid: {}", cid, inner_tid);
                    self.print_cid(cid, "cid.obj");
                    self.print_cid(new_cid, "new_cid.obj");
                    self.print_triangle(inner_tid, "ct.obj");
                    let ori = triangle_intersects_cell1(cid, inner_tri, &cell_verts, &face_planes, &face_cells, &self.points, &self.vertex_data, &mut self.vert_orientations[inner_tid], bump);
                    println!("ori: {:?}", ori);
                }*/
            }
            self.cell_data[new_cid].inner_triangles = pos_inner_triangles;
            self.cell_data[cid].inner_triangles = neg_inner_triangles;
        }
    }

    fn print_cid(&self, cid: usize, name: &str) {
        let mut explicit_points = vec![0.0; self.points.len() * 3];
        for (p, data) in self.points.iter().zip(explicit_points.chunks_mut(3)) {
            match p {
                Point3D::Explicit(p) => {
                    data[0] = p.data[0];
                    data[1] = p.data[1];
                    data[2] = p.data[2];
                }
                Point3D::LPI(p) => {
                    p.to_explicit(data);
                }
                Point3D::TPI(p) => {
                    p.to_explicit(data);
                }
            }
        }
        let mut txt = "".to_owned();
        for p in explicit_points.chunks(3) {
            txt.push_str(&format!("v {} {} {}\n", p[0], p[1], p[2]));
        }
        for &fid in &self.cell_data[cid].faces {
            txt.push_str(&format!("f"));
            for vid in self
                .mesh
                .face(fid)
                .halfedges()
                .map(|hid| self.mesh.he_vertex(hid))
            {
                txt.push_str(&format!(" {}", vid.0 + 1));
            }
            txt.push_str("\n");
        }
        std::io::Write::write_all(&mut std::fs::File::create(name).unwrap(), txt.as_bytes())
            .unwrap();
    }

    fn print_triangle(&self, tid: usize, name: &str) {
        let tri_verts = triangle(tid, &self.constraints);
        let tri_points = Vec::from_iter(
            tri_verts
                .iter()
                .map(|&vid| self.points[vid].explicit().unwrap().data),
        );
        let mut txt = "".to_owned();
        for p in tri_points {
            txt.push_str(&format!("v {} {} {}\n", p[0], p[1], p[2]));
        }
        txt.push_str(&format!("f 1 2 3\n"));
        std::io::Write::write_all(&mut std::fs::File::create(name).unwrap(), txt.as_bytes())
            .unwrap();
    }

    pub fn complex_partition(&mut self, tri_in_shell: &[usize]) -> (Vec<f64>, Vec<usize>) {
        let mut explicit_points = vec![0.0; self.points.len() * 3];
        for (p, data) in self.points.iter().zip(explicit_points.chunks_mut(3)) {
            match p {
                Point3D::Explicit(p) => {
                    data[0] = p.data[0];
                    data[1] = p.data[1];
                    data[2] = p.data[2];
                }
                Point3D::LPI(p) => {
                    p.to_explicit(data);
                }
                Point3D::TPI(p) => {
                    p.to_explicit(data);
                }
            }
        }
        let mut bump = Bump::new();
        let (face_areas, face_centers) = {
            let mut areas = Vec::with_capacity(self.face_data.len());
            let mut face_centers = Vec::with_capacity(self.face_data.len());
            for fid in self.mesh.faces() {
                bump.reset();
                let mut face_verts = Vec::new_in(&bump);
                face_verts.extend(
                    self.mesh
                        .face(fid)
                        .halfedges()
                        .map(|hid| self.mesh.he_vertex(hid)),
                );
                areas.push(face_area(&explicit_points, &face_verts, &bump));
                face_centers.push(face_center(&explicit_points, &face_verts));
            }
            let area_sum = areas.iter().sum::<f64>();
            for area in &mut areas {
                *area /= area_sum;
            }
            (areas, face_centers)
        };

        let n_shells = *tri_in_shell.iter().max().unwrap() + 1;
        let mut cell_costs_external = vec![vec![0.0; self.cell_data.len() + 1]; n_shells];
        let mut cell_costs_internal = vec![vec![0.0; self.cell_data.len() + 1]; n_shells];
        let mut is_black = vec![vec![false; self.mesh.n_faces()]; n_shells];
        for fid in self.mesh.faces() {
            let face_data = &self.face_data[fid];
            let face_triangles = &face_data.triangles;
            if face_triangles.is_empty() {
                continue;
            }

            bump.reset();
            let first_tid = face_triangles[0];
            // uncoplanar vertex
            let vert = [find_uncoplanar_verts(
                triangle(first_tid, &self.constraints),
                &mut self.vert_orientations[first_tid],
                &self.vertex_data,
                &self.points,
                &self.cell_data[face_data.cells[0]].faces,
                &self.mesh,
                &bump,
            )];

            let center_in_face = self.point_in_face(
                fid,
                &face_centers[fid],
                self.tri_orientations[face_triangles[0]],
                &bump,
            );

            for &tid in face_triangles {
                let shell_id = tri_in_shell[tid];
                if is_black[shell_id][fid] {
                    continue;
                }
                let tri = triangle(tid, &self.constraints);
                let pa = point(&explicit_points, *tri[0]);
                let pb = point(&explicit_points, *tri[1]);
                let pc = point(&explicit_points, *tri[2]);

                let axis = self.tri_orientations[tid];

                let face_intersects_tri = if center_in_face {
                    let center = face_centers[fid].explicit().unwrap();
                    let orientations = [
                        orient2d_by_axis(pa, pb, &center, axis, &bump),
                        orient2d_by_axis(pb, pc, &center, axis, &bump),
                        orient2d_by_axis(pc, pa, &center, axis, &bump),
                    ];
                    vert_in_tri(&orientations)
                } else {
                    self.face_intersects_tri(fid, tri, axis, &bump)
                };

                if face_intersects_tri {
                    verts_orient_wrt_plane(
                        &self.points[tri[0]],
                        &self.points[tri[1]],
                        &self.points[tri[2]],
                        &vert,
                        &self.points,
                        &self.vertex_data,
                        &mut self.vert_orientations[tid],
                        &bump,
                    );
                    let ori = *self.vert_orientations[tid].get(&vert[0]).unwrap();
                    if ori == Orientation::Positive {
                        // triangle is with the same orientation as the face
                        cell_costs_internal[shell_id][face_data.cells[0]] += face_areas[fid];
                        let second_cid = face_data.cells[1];
                        if second_cid != INVALID_IND {
                            cell_costs_external[shell_id][second_cid] += face_areas[fid];
                        }
                    } else {
                        cell_costs_external[shell_id][face_data.cells[0]] += face_areas[fid];
                        let second_cid = face_data.cells[1];
                        if second_cid != INVALID_IND {
                            cell_costs_internal[shell_id][second_cid] += face_areas[fid];
                        }
                    }
                    is_black[shell_id][fid] = true;
                }
            }
        }

        let mut graphs = Vec::from_iter(
            cell_costs_external
                .into_iter()
                .zip(cell_costs_internal)
                .map(|(external, mut internal)| {
                    internal[self.cell_data.len()] = 1.0;
                    GraphCut::new(&external, &internal)
                }),
        );

        for fid in self.mesh.faces() {
            let [c1, mut c2] = self.face_data[fid].cells;
            if c2 == INVALID_IND {
                c2 = self.cell_data.len();
            }

            for shell_id in 0..n_shells {
                if !is_black[shell_id][fid] {
                    graphs[shell_id].add_edge(c1, c2, face_areas[fid], face_areas[fid]);
                }
            }
        }

        let mut cell_kept = vec![false; self.cell_data.len() + 1];
        // let mut cell_kept = vec![true; self.cell_data.len() + 1];
        // *cell_kept.last_mut().unwrap() = false;
        for graph in &mut graphs {
            graph.max_flow();
            for cid in 0..self.cell_data.len() {
                cell_kept[cid] |= !graph.is_sink[cid];
            }
        }

        let mut kept_faces = vec![0; self.face_data.len()];
        for fid in self.mesh.faces() {
            let [c1, mut c2] = self.face_data[fid].cells;
            if c2 == INVALID_IND {
                c2 = self.cell_data.len();
            }

            if cell_kept[c1] ^ cell_kept[c2] {
                if cell_kept[c1] {
                    kept_faces[fid] = -1;
                } else {
                    kept_faces[fid] = 1;
                }
            }
        }

        fn project_point(p: &[f64], axis: usize) -> [f64; 2] {
            if axis == 0 {
                [p[1], p[2]]
            } else if axis == 1 {
                [p[2], p[0]]
            } else {
                [p[0], p[1]]
            }
        }
        let mut out_points = Vec::<f64>::new();
        let mut triangles = Vec::new();
        let mut v_old_to_new = vec![INVALID_IND; self.vertex_data.len()];
        let mut loop_vert_indices = vec![INVALID_IND; self.vertex_data.len()];

        for (face_verts, axis) in self.merge_faces(kept_faces) {
            bump.reset();
            let n_faces_verts = face_verts.iter().flatten().count();
            let mut points_2d = Vec::with_capacity_in(n_faces_verts << 1, &bump);
            let mut face_new_verts = Vec::with_capacity_in(n_faces_verts, &bump);
            let mut segments = Vec::new_in(&bump);
            for face_loop in &face_verts {
                // loop vertex local indices
                let mut loop_local = Vec::new_in(&bump);
                for &vid in face_loop {
                    let mut new_vid = v_old_to_new[vid];
                    if new_vid == INVALID_IND {
                        new_vid = out_points.len() / 3;
                        v_old_to_new[vid] = new_vid;
                        out_points.extend(point(&explicit_points, vid.0));
                    }
                    if loop_vert_indices[vid] == INVALID_IND {
                        loop_vert_indices[vid] = points_2d.len() >> 1;
                        points_2d.extend(project_point(point(&out_points, new_vid), axis));
                        face_new_verts.push(new_vid);
                    }

                    loop_local.push(loop_vert_indices[vid]);
                }
                segments.extend(
                    loop_local
                        .iter()
                        .circular_tuple_windows()
                        .map(|(&a, &b)| [a, b])
                        .flatten(),
                );

                // reset
                for &vid in face_loop {
                    loop_vert_indices[vid] = INVALID_IND;
                }
            }

            if face_verts.len() == 3 {
                triangles.extend(face_new_verts);
                continue;
            }

            let loop_areas = {
                let mut start = 0;
                Vec::from_iter(face_verts.iter().map(|l| {
                    let end = start + l.len();
                    let area = poly_area(&points_2d, &segments[(start << 1)..(end << 1)]);
                    start = end;
                    area
                }))
            };

            let max_loop_idx = loop_areas
                .iter()
                .map(|v| v.abs())
                .position_max_by(|a, b| a.partial_cmp(b).unwrap())
                .unwrap();

            if loop_areas[max_loop_idx] < 0.0 {
                for p in points_2d.chunks_mut(2) {
                    p.swap(0, 1);
                }
            }

            let face_triangles = triangulate(&points_2d, &segments, &bump);
            triangles.extend(face_triangles.into_iter().map(|idx| face_new_verts[idx]));
        }
        (out_points, triangles)
    }

    fn merge_faces(&self, kept_faces: Vec<i32>) -> Vec<(Vec<Vec<VertexId>>, usize)> {
        let mut edge_faces = vec![Vec::new(); self.edge_data.len()];
        let mut f_old_to_new = vec![INVALID_IND; self.face_data.len()];
        let mut f_new_to_old = Vec::new();
        for fid in self.mesh.faces() {
            if kept_faces[fid] != 0 {
                for hid in self.mesh.face(fid).halfedges() {
                    edge_faces[self.mesh.he_edge(hid)].push(fid);
                }
                f_old_to_new[fid] = f_new_to_old.len();
                f_new_to_old.push(fid);
            }
        }

        let mut ds = DisjointSet::new(f_new_to_old.len());
        for eid in self.mesh.edges() {
            let faces = &mut edge_faces[eid];
            if faces.len() == 2 {
                if self.on_the_same_plane(faces[0], faces[1]) {
                    ds.merge(f_old_to_new[faces[0]], f_old_to_new[faces[1]]);
                }
            }
        }

        let mut bump = Bump::new();
        let mut edge_groups = Vec::new();
        let mut edge_in_group = vec![INVALID_IND; self.edge_data.len()];

        let group_map = ds.output();
        let mut face_in_group = vec![INVALID_IND; self.face_data.len()];
        for (&id, new_faces) in &group_map {
            for &new_fid in new_faces {
                face_in_group[f_new_to_old[new_fid]] = id;
            }
        }
        let edge_face_groups = Vec::from_iter(edge_faces.iter().map(|faces| {
            let mut groups = Vec::from_iter(faces.into_iter().map(|&fid| face_in_group[fid]));
            groups.sort_unstable();
            groups.dedup();
            groups
        }));

        Vec::from_iter(group_map.into_values().map(|indices| {
            bump.reset();
            let mut tid = INVALID_IND;
            let mut base_fid = FaceId::new();
            let faces = Vec::from_iter(indices.into_iter().map(|idx| {
                let fid = f_new_to_old[idx];
                if !base_fid.valid() {
                    base_fid = fid;
                }
                if tid == INVALID_IND && !self.face_data[fid].triangles.is_empty() {
                    tid = self.face_data[fid].triangles[0];
                }
                fid
            }));

            let outline_groups = self.extract_faces_outlines(&faces, &kept_faces, &bump);

            let axis = if tid != INVALID_IND {
                self.tri_orientations[tid]
            } else {
                let [pa, pb, pc] = self.face_data[base_fid]
                    .plane
                    .map(|vid| self.points[vid].explicit().unwrap());
                max_comp_in_tri_normal(pa, pb, pc, &bump)
            };

            (
                Vec::from_iter(outline_groups.into_iter().map(|outline| {
                    self.merge_colinear_edges(
                        outline,
                        &mut edge_groups,
                        &mut edge_in_group,
                        &edge_face_groups,
                        axis,
                        &bump,
                    )
                })),
                axis,
            )
        }))
    }

    fn extract_faces_outlines<A: Allocator + Copy>(
        &self,
        faces: &[FaceId],
        face_signs: &[i32],
        bump: A,
    ) -> Vec<Vec<(EdgeId, bool)>> {
        let mut edge_map = HashMap::new();
        for &fid in faces {
            for hid in self.mesh.face(fid).halfedges() {
                let eid = self.mesh.he_edge(hid);
                *edge_map.entry(eid).or_insert(0) +=
                    if self.mesh.he_same_dir(hid) ^ (face_signs[fid] > 0) {
                        -1
                    } else {
                        1
                    };
            }
        }

        // all outline halfedges
        let halfedges = Vec::from_iter(edge_map.into_iter().filter_map(|(eid, count)| {
            if count == 0 {
                None
            } else {
                if count > 0 {
                    Some((eid, false))
                } else {
                    Some((eid, true))
                }
            }
        }));

        enum HalfedgeGroup {
            Single(usize),
            Group(Vec<usize>),
        }

        let mut vert_out_edge_map = hashbrown::HashMap::<VertexId, HalfedgeGroup, _, _>::new_in(bump);
        let mut multi_out_verts = HashSet::new();
        for (i, &(eid, reversed)) in halfedges.iter().enumerate() {
            let [ea, eb] = self.mesh.e_vertices(eid);
            let v = if reversed { eb } else { ea };
            match vert_out_edge_map.entry(v) {
                hashbrown::hash_map::Entry::Occupied(mut entry) => match entry.get_mut() {
                    HalfedgeGroup::Single(hid) => {
                        multi_out_verts.insert(v);
                        *entry.into_mut() = HalfedgeGroup::Group(vec![*hid, i]);
                    }
                    HalfedgeGroup::Group(group) => {
                        group.push(i);
                    }
                },
                hashbrown::hash_map::Entry::Vacant(entry) => {
                    entry.insert(HalfedgeGroup::Single(i));
                }
            }
        }

        let mut he_next_map = HashMap::new();
        if !multi_out_verts.is_empty() {
            for &fid in faces {
                for hid in self.mesh.face(fid).halfedges() {
                    let v = self.mesh.he_tip_vertex(hid);
                    if multi_out_verts.contains(&v) {
                        let (mut ha, mut hb) = (
                            self.mesh.he_edge(hid),
                            self.mesh.he_edge(self.mesh.he_next(hid)),
                        );
                        if face_signs[fid] < 0 {
                            std::mem::swap(&mut ha, &mut hb);
                        }
                        he_next_map.insert(ha, hb);
                    }
                }
            }
        }

        let end_vertex = |he: &(EdgeId, bool)| {
            if he.1 {
                self.mesh.he_vertex(self.mesh.e_halfedge(he.0))
            } else {
                self.mesh.he_tip_vertex(self.mesh.e_halfedge(he.0))
            }
        };

        let mut visisted = std::vec::from_elem_in(false, halfedges.len(), bump);

        let mut outlines = Vec::new();
        for (i, he) in halfedges.iter().enumerate() {
            if visisted[i] {
                continue;
            }
            visisted[i] = true;
            let mut outline = vec![he.clone()];
            loop {
                let he = outline.last().unwrap();
                let vb = end_vertex(he);
                let next_hid_candidates = vert_out_edge_map.get(&vb).unwrap();
                let next_hid = match next_hid_candidates {
                    HalfedgeGroup::Single(idx) => *idx,
                    HalfedgeGroup::Group(group) => {
                        if group.iter().filter(|&&idx| !visisted[idx]).count() == 1 {
                            *group.iter().find(|&&idx| !visisted[idx]).unwrap()
                        } else {
                            let mut cur = he.0;
                            let next_hid;
                            loop {
                                let next = *he_next_map.get(&cur).unwrap();
                                if let Some(&hid) =
                                    group.iter().find(|&&idx| halfedges[idx].0 == next)
                                {
                                    next_hid = hid;
                                    break;
                                } else {
                                    cur = next;
                                }
                            }
                            next_hid
                        }
                    }
                };
                if visisted[next_hid] {
                    break;
                }
                visisted[next_hid] = true;
                outline.push(halfedges[next_hid]);
            }
            outlines.push(outline);
        }
        outlines
    }

    fn merge_colinear_edges<A: Allocator + Copy>(
        &self,
        outline: Vec<(EdgeId, bool)>,
        edge_groups: &mut Vec<EdgeGroup>,
        edge_in_group: &mut [usize],
        edge_face_groups: &[Vec<usize>],
        axis: usize,
        bump: A,
    ) -> Vec<VertexId> {
        enum Edge {
            Edges(Vec<(EdgeId, bool)>),
            Group((usize, bool)),
        }
        let end_vertex = |he: &(EdgeId, bool)| {
            if he.1 {
                self.mesh.he_vertex(self.mesh.e_halfedge(he.0))
            } else {
                self.mesh.he_tip_vertex(self.mesh.e_halfedge(he.0))
            }
        };

        let colinear = |ha: &(EdgeId, bool), hb: &(EdgeId, bool)| {
            let ea = ha.0;
            let eb = hb.0;
            if edge_face_groups[ea] != edge_face_groups[eb] {
                return false;
            }

            if self.edge_data[ha.0].id == self.edge_data[hb.0].id {
                return true;
            }

            let [va, vb] = self.mesh.e_vertices(ea);
            let vc = end_vertex(hb);
            let [pa, pb, pc] = [va, vb, vc].map(|vid| &self.points[vid]);
            orient2d::orient2d_by_axis(pa, pb, pc, axis, bump) == Orientation::Zero
        };
        let start_idx = outline
            .iter()
            .position(|he| edge_in_group[he.0] == INVALID_IND);
        let halfedges = if let Some(start_idx) = start_idx {
            let mut halfedges = Vec::<Edge>::new();
            let mut cur_group = Vec::new();
            for i in 0..outline.len() {
                let idx = i + start_idx;
                let he = &outline[idx];
                let group_id = edge_in_group[he.0];
                if group_id != INVALID_IND {
                    if !cur_group.is_empty() {
                        halfedges.push(Edge::Edges(cur_group));
                        cur_group = Vec::new();
                    }
                    if let Some(prev_group) = halfedges.last() {
                        if let Edge::Group(prev_group) = prev_group {
                            if group_id == prev_group.0 {
                                continue;
                            }
                        }
                    }
                    let group = &edge_groups[group_id];
                    let pos = group.position(he.0);
                    if group.edges[pos].1 == he.1 {
                        halfedges.push(Edge::Group((group_id, false)));
                    } else {
                        halfedges.push(Edge::Group((group_id, true)));
                    }
                } else {
                    if let Some(prev) = cur_group.last() {
                        if colinear(prev, he) {
                            cur_group.push(he.clone());
                        } else {
                            halfedges.push(Edge::Edges(cur_group));
                            cur_group = vec![he.clone()];
                        }
                    } else {
                        cur_group.push(he.clone());
                    }
                }
            }
            if !cur_group.is_empty() {
                if let Edge::Edges(first_group) = &halfedges[0] {
                    if colinear(cur_group.last().unwrap(), &first_group[0]) {
                        cur_group.extend(first_group);
                        halfedges[0] = Edge::Edges(cur_group);
                    } else {
                        halfedges.push(Edge::Edges(cur_group));
                    }
                }
            }
            Vec::from_iter(halfedges.into_iter().map(|ele| match ele {
                Edge::Edges(edges) => {
                    let group_id = edge_groups.len();
                    edge_groups.push(EdgeGroup::new(edges));
                    (group_id, false)
                }
                Edge::Group(group) => group,
            }))
        } else {
            let mut halfedges = Vec::<(usize, bool)>::new();
            for (eid, reversed) in outline {
                let group_id = edge_in_group[eid];
                if let Some(last_group) = halfedges.last() {
                    if last_group.0 == group_id {
                        continue;
                    }
                }
                let group = &edge_groups[edge_in_group[eid]];
                let idx = group.position(eid);
                if group.edges[idx].1 == reversed {
                    halfedges.push((group_id, false));
                } else {
                    halfedges.push((group_id, true));
                }
            }
            if halfedges.first().unwrap().0 == halfedges.last().unwrap().0 {
                halfedges.pop();
            }
            halfedges
        };

        Vec::from_iter(halfedges.into_iter().map(|(group_id, reversed)| {
            let group = &edge_groups[group_id];
            if reversed {
                let (eid, reversed) = group.edges[0];
                end_vertex(&(eid, !reversed))
            } else {
                end_vertex(group.edges.last().unwrap())
            }
        }))
    }

    #[inline(always)]
    fn triangle(&self, tid: usize) -> &[VertexId] {
        let start = tid * 3;
        &self.constraints[start..(start + 3)]
    }

    #[inline(always)]
    fn is_virtual(&self, tid: usize) -> bool {
        tid >= self.n_ori_triangles
    }

    fn separate_out_coplanar_triangles<A: Allocator + Copy>(
        &mut self,
        pivot_tid: usize,
        cid: usize,
        bump: A,
    ) -> Vec<usize> {
        let mut plane_pts = Vec::with_capacity_in(3, bump);
        plane_pts.extend(
            self.triangle(pivot_tid)
                .iter()
                .map(|&vid| &self.points[vid]),
        );
        let mut coplanar_triangles = Vec::new();
        self.cell_data[cid].inner_triangles.retain(|&tid| {
            let start = tid * 3;
            let tri = &self.constraints[start..(start + 3)];
            verts_orient_wrt_plane(
                plane_pts[0],
                plane_pts[1],
                plane_pts[2],
                tri,
                &self.points,
                &self.vertex_data,
                &mut self.vert_orientations[pivot_tid],
                bump,
            );
            let ori = &self.vert_orientations[pivot_tid];
            let coplanar = *ori.get(&tri[0]).unwrap() == Orientation::Zero
                && *ori.get(&tri[1]).unwrap() == Orientation::Zero
                && *ori.get(&tri[2]).unwrap() == Orientation::Zero;
            if coplanar && tid < self.n_ori_triangles {
                coplanar_triangles.push(tid);
            }
            !coplanar
        });
        coplanar_triangles
    }

    #[inline]
    fn cell_verts_and_edges<A: Allocator + Copy>(
        &mut self,
        cid: usize,
        bump: A,
    ) -> (Vec<VertexId, A>, Vec<EdgeId, A>) {
        let mesh = &self.mesh;
        let mut verts = Vec::new_in(bump);
        let mut edges = Vec::new_in(bump);
        for &fid in &self.cell_data[cid].faces {
            for hid in mesh.face(fid.into()).halfedges() {
                let vid = mesh.he_vertex(hid);
                if !self.vert_visits[vid] {
                    self.vert_visits[vid] = true;
                    verts.push(vid);
                }
                let eid = mesh.he_edge(hid);
                if !self.edge_visits[eid] {
                    self.edge_visits[eid] = true;
                    edges.push(eid);
                }
            }
        }
        for &vid in &verts {
            self.vert_visits[vid] = false;
        }
        for &eid in &edges {
            self.edge_visits[eid] = false;
        }
        (verts, edges)
    }

    #[inline]
    fn split_edge<A: Allocator + Copy>(
        &mut self,
        eid: EdgeId,
        tri: &[VertexId],
        bump: A,
    ) -> VertexId {
        let vid = self.mesh.split_edge(eid, bump);
        self.edge_visits.push(false);
        let p0 = self.points[tri[0]].explicit().unwrap().clone();
        let p1 = self.points[tri[1]].explicit().unwrap().clone();
        let p2 = self.points[tri[2]].explicit().unwrap().clone();
        let ori_edge_parents = self.edge_data[eid].parents.clone();
        if ori_edge_parents.len() > 2 {
            self.points.push(three_planes_intersection(
                [&ori_edge_parents[..3], &ori_edge_parents[3..], tri],
                &self.points,
                bump,
            ));
        } else {
            self.points.push(Point3D::LPI(ImplicitPointLPI::new(
                self.points[ori_edge_parents[0]].explicit().unwrap().clone(),
                self.points[ori_edge_parents[1]].explicit().unwrap().clone(),
                p0,
                p1,
                p2,
            )));
        }
        self.vert_visits.push(false);

        self.edge_visits.push(false);
        self.edge_data
            .push(BSPEdgeData::new(ori_edge_parents, self.edge_data.len()));
        vid
    }

    fn get_ef_clip_pt<A: Allocator + Copy>(
        &mut self,
        eid: EdgeId,
        tri: &[VertexId],
        bump: A,
    ) -> Point3D {
        let p0 = self.points[tri[0]].explicit().unwrap().clone();
        let p1 = self.points[tri[1]].explicit().unwrap().clone();
        let p2 = self.points[tri[2]].explicit().unwrap().clone();
        let ori_edge_parents = self.edge_data[eid].parents.clone();
        if ori_edge_parents.len() > 2 {
            three_planes_intersection(
                [&ori_edge_parents[..3], &ori_edge_parents[3..], tri],
                &self.points,
                bump,
            )
        } else {
            Point3D::LPI(ImplicitPointLPI::new(
                self.points[ori_edge_parents[0]].explicit().unwrap().clone(),
                self.points[ori_edge_parents[1]].explicit().unwrap().clone(),
                p0,
                p1,
                p2,
            ))
        }
    }

    fn face_intersects_tri<A: Allocator + Copy>(
        &self,
        fid: FaceId,
        tri: &[VertexId],
        axis: usize,
        bump: A,
    ) -> bool {
        let mut verts = Vec::new_in(bump);
        verts.extend(
            self.mesh
                .face(fid)
                .halfedges()
                .map(|hid| self.mesh.he_vertex(hid)),
        );
        let mut orientations = Vec::with_capacity_in(verts.len(), bump);

        for &vid in verts.iter() {
            let p = &self.points[vid];
            let mut tri_points = Vec::with_capacity_in(3, bump);
            tri_points.extend(tri.iter().map(|&v| &self.points[v]));
            let mut vert_orientations = Vec::with_capacity_in(3, bump);
            vert_orientations.extend(
                tri_points
                    .into_iter()
                    .circular_tuple_windows()
                    .map(|(pa, pb)| orient2d::orient2d_by_axis(pa, pb, p, axis, bump)),
            );

            // intersect in inner
            if vert_orientations
                .iter()
                .all(|&ori| ori == vert_orientations[0])
            {
                return true;
            }
            orientations.push(vert_orientations);
        }
        for (i, j) in (0..verts.len()).circular_tuple_windows() {
            for k in 0..3 {
                if sign_reversed(orientations[i][k], orientations[j][k]) {
                    let pa = &self.points[verts[i]];
                    let pb = &self.points[verts[j]];
                    let pc = &self.points[tri[k]];
                    let pd = &self.points[tri[(k + 1) % 3]];
                    if sign_reversed(
                        orient2d::orient2d_by_axis(pa, pb, pc, axis, bump),
                        orient2d::orient2d_by_axis(pa, pb, pd, axis, bump),
                    ) {
                        return true;
                    }
                }
            }
        }
        false
    }

    #[inline]
    fn point_in_face<A: Allocator + Copy>(
        &self,
        fid: FaceId,
        center: &Point3D,
        axis: usize,
        bump: A,
    ) -> bool {
        let mut face_points = Vec::new_in(bump);
        face_points.extend(
            self.mesh
                .face(fid)
                .halfedges()
                .map(|hid| self.mesh.he_vertex(hid))
                .map(|vid| &self.points[vid]),
        );

        let mut base_ori = Orientation::Undefined;
        for (pa, pb) in face_points.into_iter().circular_tuple_windows() {
            let ori = orient2d::orient2d_by_axis(pa, pb, center, axis, bump);
            if ori == Orientation::Zero {
                return false;
            }
            if base_ori == Orientation::Undefined {
                base_ori = ori;
            } else if base_ori != ori {
                return false;
            }
        }
        true
    }

    #[inline(always)]
    fn on_the_same_plane(&self, fa: FaceId, fb: FaceId) -> bool {
        let fa_data = &self.face_data[fa];
        let fb_data = &self.face_data[fb];
        if fa_data.id == fb_data.id {
            return true;
        }

        if !fa_data.triangles.is_empty() && !fb_data.triangles.is_empty() {
            if fa_data
                .triangles
                .iter()
                .any(|tid| fb_data.triangles.contains(tid))
            {
                return true;
            }
        }

        false
    }
}

fn triangle(tid: usize, triangles: &[VertexId]) -> &[VertexId] {
    let start = tid * 3;
    &triangles[start..(start + 3)]
}

fn remove_ghost_tets<'b>(mesh: &TetMesh) -> Vec<usize> {
    let tets = &mesh.tets;
    let mut idx = 0;
    let mut new_orders = vec![INVALID_IND; tets.len()];
    for tid in 0..tets.len() {
        if !mesh.is_hull_tet(tid) {
            new_orders[tid] = idx;
            idx += 1;
        }
    }
    new_orders
}

fn insert_coplanar_triangles(src: &[usize], dest: &mut Vec<usize>, n_constraints: usize) {
    for &idx in src {
        if idx < n_constraints {
            if let Err(pos) = dest.binary_search(&idx) {
                dest.insert(pos, idx);
            }
        }
    }
}

#[inline]
fn verts_orient_wrt_plane<A: Allocator + Copy>(
    pa: &Point3D,
    pb: &Point3D,
    pc: &Point3D,
    verts: &[VertexId],
    points: &[Point3D],
    vertex_data: &[BSPVertexData],
    vert_orientations: &mut HashMap<VertexId, Orientation>,
    bump: A,
) {
    let p0 = pa.explicit().unwrap();
    let p1 = pb.explicit().unwrap();
    let p2 = pc.explicit().unwrap();
    for &vid in verts {
        if vert_orientations.contains_key(&vid) {
            continue;
        }
        let vp = &vertex_data[vid].parent;
        // inside a segment
        if vid != vp[0] {
            if !vert_orientations.contains_key(&vp[0]) || !vert_orientations.contains_key(&vp[1]) {
                verts_orient_wrt_plane(
                    pa,
                    pb,
                    pc,
                    vp,
                    points,
                    vertex_data,
                    vert_orientations,
                    bump,
                );
            }
            let ori_a = *vert_orientations.get(&vp[0]).unwrap();
            let ori_b = *vert_orientations.get(&vp[1]).unwrap();
            if ori_a == ori_b {
                vert_orientations.insert(vid, ori_a);
                continue;
            }
            if ori_a == Orientation::Zero {
                vert_orientations.insert(vid, ori_b);
                continue;
            }
            if ori_b == Orientation::Zero {
                vert_orientations.insert(vid, ori_a);
                continue;
            }
        }

        if is_point_built_from_plane(&points[vid], p0, p1, p2) {
            vert_orientations.insert(vid, Orientation::Zero);
        } else {
            vert_orientations.insert(vid, orient3d(pa, pb, pc, &points[vid], bump));
        }
    }
}

#[inline(always)]
fn is_point_built_from_plane(
    p: &Point3D,
    pa: &ExplicitPoint3D,
    pb: &ExplicitPoint3D,
    pc: &ExplicitPoint3D,
) -> bool {
    match p {
        Point3D::Explicit(p) => {
            if p == pa || p == pb || p == pc {
                return true;
            }
        }
        Point3D::LPI(lpi) => {
            if (((pa == &lpi.p) && (pb == &lpi.q)) || ((pb == &lpi.p) && (pa == &lpi.q)))
                || (((pb == &lpi.p) && (pc == &lpi.q)) || ((pc == &lpi.p) && (pb == &lpi.q)))
                || (((pc == &lpi.p) && (pa == &lpi.q)) || ((pa == &lpi.p) && (pc == &lpi.q)))
                || ((pa == &lpi.r) && (pb == &lpi.s) && (pc == &lpi.t))
            {
                return true;
            }
        }
        Point3D::TPI(tpi) => {
            if ((pa == &tpi.v1) && (pb == &tpi.v2) && (pc == &tpi.v3))
                || ((pa == &tpi.w1) && (pb == &tpi.w2) && (pc == &tpi.w3))
                || ((pa == &tpi.u1) && (pb == &tpi.u2) && (pc == &tpi.u3))
            {
                return true;
            }
        }
    }
    return false;
}

#[inline]
fn three_planes_intersection<A: Allocator + Copy>(
    planes: [&[VertexId]; 3],
    points: &[Point3D],
    bump: A,
) -> Point3D {
    for (&tri, &tri1, &tri2) in planes.iter().circular_tuple_windows() {
        let mut common = Vec::new_in(bump);
        for va in tri1 {
            if tri2.contains(va) {
                common.push(*va);
            }
            if common.len() > 1 {
                break;
            }
        }
        if common.len() > 1 {
            return Point3D::LPI(ImplicitPointLPI::new(
                points[common[0]].explicit().unwrap().clone(),
                points[common[1]].explicit().unwrap().clone(),
                points[tri[0]].explicit().unwrap().clone(),
                points[tri[1]].explicit().unwrap().clone(),
                points[tri[2]].explicit().unwrap().clone(),
            ));
        }
    }
    let [t0, t1, t2] = planes;
    Point3D::TPI(ImplicitPointTPI::new(
        points[t0[0]].explicit().unwrap().clone(),
        points[t0[1]].explicit().unwrap().clone(),
        points[t0[2]].explicit().unwrap().clone(),
        points[t1[0]].explicit().unwrap().clone(),
        points[t1[1]].explicit().unwrap().clone(),
        points[t1[2]].explicit().unwrap().clone(),
        points[t2[0]].explicit().unwrap().clone(),
        points[t2[1]].explicit().unwrap().clone(),
        points[t2[2]].explicit().unwrap().clone(),
    ))
}

enum GeneralVertexId {
    Vertex(VertexId),
    Index(usize),
}

#[derive(Debug, Clone)]
enum ZeroVert {
    Intersection(HalfedgeId),
    Start(HalfedgeId),
}

impl ZeroVert {
    #[inline(always)]
    fn is_intersection(&self) -> bool {
        match self {
            ZeroVert::Intersection(_) => true,
            _ => false,
        }
    }
    #[inline(always)]
    fn unwrap_halfedge(&self) -> HalfedgeId {
        match self {
            ZeroVert::Intersection(hid) => *hid,
            ZeroVert::Start(hid) => *hid,
        }
    }
    // #[inline(always)]
    fn id(&self, mesh: &SurfaceMesh, ef_clip_pt_map: &HashMap<EdgeId, usize>) -> GeneralVertexId {
        match self {
            ZeroVert::Intersection(he) => GeneralVertexId::Index(ef_clip_pt_map[&mesh.he_edge(*he)]),
            ZeroVert::Start(he) => GeneralVertexId::Vertex(mesh.he_vertex(*he))
        }
    }
}

#[derive(Debug, Clone)]
enum SplitFaceResult {
    TwoVerts([ZeroVert; 2]),
    ZeroHalfedges(Vec<HalfedgeId>),
    IsPos(bool),
}

impl SplitFaceResult {
    #[inline]
    fn start(&self, mesh: &SurfaceMesh, ef_clip_pt_map: &HashMap<EdgeId, usize>) -> GeneralVertexId {
        match self {
            SplitFaceResult::TwoVerts([va, _]) => va.id(mesh, ef_clip_pt_map),
            SplitFaceResult::ZeroHalfedges(halfedges) => {
                GeneralVertexId::Vertex(mesh.he_vertex(halfedges[0]))
            }
            _ => panic!("Get start from none split result"),
        }
    }

    #[inline]
    fn end(&self, mesh: &SurfaceMesh, ef_clip_pt_map: &HashMap<EdgeId, usize>) -> GeneralVertexId {
        match self {
            SplitFaceResult::TwoVerts([_, vb]) => vb.id(mesh, ef_clip_pt_map),
            SplitFaceResult::ZeroHalfedges(halfedges) => {
                GeneralVertexId::Vertex(mesh.he_tip_vertex(*halfedges.last().unwrap()))
            }
            _ => panic!("Get end from none split result"),
        }
    }
}

fn split_face_verts1(
    mesh: &SurfaceMesh,
    fid: FaceId,
    vert_orientations: &HashMap<VertexId, Orientation>,
) -> SplitFaceResult {
    let mut ori_start = *vert_orientations
        .get(&*mesh.face(fid).halfedge().vertex())
        .unwrap();
    let mut base_ori = if ori_start != Orientation::Zero {
        ori_start
    } else {
        Orientation::Undefined
    };
    let mut zero_candidates = Vec::new();
    for hid in mesh.face(fid).halfedges() {
        let vid = mesh.he_tip_vertex(hid);
        let ori_end = *vert_orientations.get(&vid).unwrap();
        if ori_start == Orientation::Zero {
            zero_candidates.push(ZeroVert::Start(hid));
            if base_ori == Orientation::Undefined && ori_end != Orientation::Zero {
                base_ori = ori_end;
            }
        } else {
            if ori_end != Orientation::Zero && ori_end != ori_start {
                zero_candidates.push(ZeroVert::Intersection(hid));
                if zero_candidates.len() == 2 {
                    if ori_end == Orientation::Positive {
                        return SplitFaceResult::TwoVerts([
                            zero_candidates[0].clone(),
                            zero_candidates[1].clone(),
                        ]);
                    } else {
                        return SplitFaceResult::TwoVerts([
                            zero_candidates[1].clone(),
                            zero_candidates[0].clone(),
                        ]);
                    }
                }
            }
        }
        ori_start = ori_end;
    }

    //all halfedges round counterclockwise
    let sort_two_verts = |mut verts: [ZeroVert; 2]| -> SplitFaceResult {
        if vert_orientations[&mesh.he_tip_vertex(verts[1].unwrap_halfedge())]
            != Orientation::Positive
        {
            verts.swap(0, 1);
        }
        SplitFaceResult::TwoVerts(verts)
    };

    let sort_zero_halfedges = |mut halfedges: Vec<HalfedgeId>| -> SplitFaceResult {
        let hid = *halfedges.last().unwrap();
        if vert_orientations[&mesh.he_tip_vertex(hid)] != Orientation::Positive {
            halfedges.reverse();
            halfedges.iter_mut().for_each(|h| *h = mesh.he_twin(*h));
        }
        SplitFaceResult::ZeroHalfedges(halfedges)
    };

    match zero_candidates.len() {
        // if less than 2 zero vertices
        0 | 1 => SplitFaceResult::IsPos(base_ori == Orientation::Positive),
        2 => {
            if zero_candidates[0].is_intersection() || zero_candidates[1].is_intersection() {
                sort_two_verts([zero_candidates[0].clone(), zero_candidates[1].clone()])
            } else {
                let ha = zero_candidates[0].unwrap_halfedge();
                let hb = zero_candidates[1].unwrap_halfedge();
                if mesh.he_tip_vertex(ha) == mesh.he_vertex(hb) {
                    sort_zero_halfedges(vec![ha])
                } else if mesh.he_tip_vertex(hb) == mesh.he_vertex(ha) {
                    sort_zero_halfedges(vec![hb])
                } else {
                    sort_two_verts([zero_candidates[0].clone(), zero_candidates[1].clone()])
                }
            }
        }
        _ => {
            // find break point
            let pos = (0..zero_candidates.len() - 1).find(|&i| {
                mesh.he_tip_vertex(zero_candidates[i].unwrap_halfedge())
                    != mesh.he_vertex(zero_candidates[i + 1].unwrap_halfedge())
            });
            if let Some(pos) = pos {
                zero_candidates.rotate_left(pos + 1);
            }
            zero_candidates.pop();
            sort_zero_halfedges(
                zero_candidates
                    .into_iter()
                    .map(|v| v.unwrap_halfedge())
                    .collect(),
            )
        }
    }
}

fn split_face_verts<A: Allocator + Copy>(
    mesh: &SurfaceMesh,
    fid: FaceId,
    vert_orientations: &HashMap<VertexId, Orientation>,
    bump: A,
) -> Result<[VertexId; 2], Result<Vec<HalfedgeId, A>, bool>> {
    let (mut first, mut second) = (None, None);
    let (mut has_pos, mut has_neg) = (false, false);
    let mut zero_ori_candidates = Vec::new_in(bump);
    for hid in mesh.face(fid).halfedges() {
        let vid = mesh.he_vertex(hid);
        match vert_orientations.get(&vid).unwrap() {
            Orientation::Positive => {
                has_pos = true;
                if has_neg
                    && let Some(first) = first
                    && let Some(second) = second
                {
                    return Ok([first, second]);
                }
            }
            Orientation::Negative => {
                has_neg = true;
                if has_pos
                    && let Some(first) = first
                    && let Some(second) = second
                {
                    return Ok([first, second]);
                }
            }
            Orientation::Zero => {
                zero_ori_candidates.push(hid);
                if first.is_none() {
                    first = Some(vid);
                } else if second.is_none() {
                    if has_pos && has_neg {
                        return Ok([first.unwrap(), vid]);
                    } else {
                        second = Some(vid);
                    }
                }
            }
            Orientation::Undefined => {}
        }
    }

    zero_ori_candidates.retain(|&hid| {
        vert_orientations.get(&mesh.he_tip_vertex(hid)).unwrap() == &Orientation::Zero
    });

    if zero_ori_candidates.is_empty() {
        return Err(Err(has_pos));
    } else {
        if zero_ori_candidates.len() == 1 {
            return Err(Ok(zero_ori_candidates));
        } else {
            // find break point
            let pos = (0..zero_ori_candidates.len() - 1).find(|i| {
                mesh.he_tip_vertex(zero_ori_candidates[*i])
                    != mesh.he_vertex(zero_ori_candidates[*i + 1])
            });
            if let Some(pos) = pos {
                zero_ori_candidates.rotate_left(pos + 1);
            }
            return Err(Ok(zero_ori_candidates));
        }
    }
}

fn make_loop1(
    mesh: &SurfaceMesh,
    halfedges: Vec<SplitFaceResult>,
    ef_clip_pt_map: &HashMap<EdgeId, usize>,
) -> Vec<SplitFaceResult> {
    let mut map = std::collections::HashMap::new();

    let start = |split: &SplitFaceResult| match split.start(mesh, ef_clip_pt_map) {
        GeneralVertexId::Vertex(vid) => vid.0,
        GeneralVertexId::Index(idx) => idx + mesh.n_vertices(),
    };

    let end = |split_ret: &SplitFaceResult| match split_ret.end(mesh, ef_clip_pt_map) {
        GeneralVertexId::Vertex(vid) => vid.0,
        GeneralVertexId::Index(idx) => idx + mesh.n_vertices(),
    };

    map.extend(
        halfedges
            .iter()
            .enumerate()
            .map(|(i, split)| (start(split), i)),
    );
    let mut result = vec![0];
    let mut curr = 0;
    loop {
        let next = map[&end(&halfedges[curr])];
        if next == 0 {
            break;
        }
        result.push(next);
        curr = next;
    }
    result.into_iter().map(|i| halfedges[i].clone()).collect()
}

fn make_loop<A: Allocator + Copy>(
    mesh: &SurfaceMesh,
    halfedges: Vec<HalfedgeId, A>,
) -> Vec<HalfedgeId, A> {
    let bump = *halfedges.allocator();
    let mut map = HashMap::new();
    map.extend(halfedges.iter().map(|&hid| (mesh.he_vertex(hid), hid)));

    let first = halfedges[0];
    let mut result = Vec::new_in(bump);
    result.push(first);
    let mut curr = first;
    loop {
        let next = *map.get(&mesh.he_tip_vertex(curr)).unwrap();
        if next == first {
            break;
        }
        result.push(next);
        curr = next;
    }
    result
}

fn is_triangle_intersects_cell<A: Allocator + Copy>(
    cid: usize,
    tri: &[VertexId],
    cell_verts: &[VertexId],
    cell: &[FaceId],
    points: &[Point3D],
    vertex_data: &[BSPVertexData],
    face_data: &[BSPFaceData],
    vert_orientations: &mut HashMap<VertexId, Orientation>,
    bump: A,
) -> bool {
    let tri_points = [&points[tri[0]], &points[tri[1]], &points[tri[2]]];
    verts_orient_wrt_plane(
        tri_points[0],
        tri_points[1],
        tri_points[2],
        cell_verts,
        points,
        vertex_data,
        vert_orientations,
        bump,
    );
    // all orientations are the same
    {
        let mut first_ori = Orientation::Undefined;
        for vid in cell_verts {
            let ori = vert_orientations[vid];
            match ori {
                Orientation::Positive | Orientation::Negative => {
                    if first_ori == Orientation::Undefined {
                        first_ori = ori;
                    } else if first_ori != ori {
                        first_ori = Orientation::Zero;
                        break;
                    }
                }
                _ => {}
            }
        }

        if first_ori != Orientation::Zero {
            return false; // all verts are on the same side of the triangle, not intersect property
        }
    }

    for fid in cell {
        let data = &face_data[fid.0];
        let plane_verts = data.plane;
        let plane_points: [&[f64]; 3] =
            plane_verts.map(|vid| points[vid].explicit().unwrap().deref());
        let tri_pt_oris = tri_points.map(|p| {
            double_to_sign(-crate::predicates::orient3d(
                plane_points[0],
                plane_points[1],
                plane_points[2],
                p.explicit().unwrap().deref(),
                bump,
            ))
        });
        if tri_pt_oris.iter().all(|&ori| ori == Orientation::Zero) {
            return false; // intersect, but not intersect properly
        }
        let base_ori = if data.cells[0] == cid {
            Orientation::Positive
        } else {
            Orientation::Negative
        };
        if tri_pt_oris
            .into_iter()
            .filter(|&ori| ori != Orientation::Zero)
            .all(|ori| ori != base_ori)
        {
            return false; // all points are on the same side of the face
        }
    }
    return true;
}

fn is_triangle_intersects_poly<A: Allocator + Copy>(
    tri: &[&Point3D],
    poly: &[&Point3D],
    axis: usize,
    alloc: A,
) -> bool {
    let base_ori = orient2d::orient2d_by_axis(poly[0], poly[1], poly[2], axis, alloc);
    {
        let mut all_poly_verts_inside = [true; 3];
        for (i, (&pa, &pb)) in tri.iter().circular_tuple_windows().enumerate() {
            let mut has_inside = false;
            for &pc in poly {
                let ori = orient2d::orient2d_by_axis(pa, pb, pc, axis, alloc);
                if ori == Orientation::Zero {
                    continue;
                }

                if ori == base_ori {
                    has_inside = true;
                } else {
                    all_poly_verts_inside[i] = false;
                }
            }
            if !has_inside {
                return false;
            }
        }
        if all_poly_verts_inside.iter().all(|&b| b) {
            return true;
        }
    }
    {
        for (&pa, &pb) in poly.iter().circular_tuple_windows() {
            let mut has_inside = false;
            for &pc in tri {
                let ori = orient2d::orient2d_by_axis(pa, pb, pc, axis, alloc);
                if ori == Orientation::Zero {
                    continue;
                }
                if ori == base_ori {
                    has_inside = true;
                }
            }
            if !has_inside {
                return false;
            }
        }
    }
    true
}

#[inline(always)]
fn find_uncoplanar_verts<A: Allocator + Copy>(
    tri: &[VertexId],
    orientations: &mut HashMap<VertexId, Orientation>,
    vertex_data: &[BSPVertexData],
    points: &[Point3D],
    faces: &[FaceId],
    mesh: &SurfaceMesh,
    bump: A,
) -> VertexId {
    let pa = &points[tri[0]];
    let pb = &points[tri[1]];
    let pc = &points[tri[2]];
    for &fid in faces {
        for vid in mesh.face(fid).halfedges().map(|hid| mesh.he_vertex(hid)) {
            verts_orient_wrt_plane(pa, pb, pc, &[vid], &points, vertex_data, orientations, bump);
            if *orientations.get(&vid).unwrap() != Orientation::Zero {
                return vid;
            }
        }
    }
    panic!("no uncoplanar vertex in cell");
}

#[inline(always)]
fn face_area<A: Allocator + Copy>(points: &[f64], verts: &[VertexId], bump: A) -> f64 {
    let pa = point(points, verts[0].0);
    let mut v1 = Vec::with_capacity_in(3, bump);
    v1.resize(3, 0.0);
    let mut v2 = Vec::with_capacity_in(3, bump);
    v2.resize(3, 0.0);
    let mut n = Vec::with_capacity_in(3, bump);
    n.resize(3, 0.0);
    let mut area = 0.0;
    for two_verts in verts[1..].windows(2) {
        let pb = point(points, two_verts[0].0);
        sub(pb, pa, &mut v1);
        let pc = point(points, two_verts[1].0);
        sub(pc, pa, &mut v2);
        cross(&v1, &v2, &mut n);
        area += norm(&n);
    }
    return area;
}

#[inline(always)]
fn face_center(points: &[f64], verts: &[VertexId]) -> Point3D {
    let mut result = [0.0; 3];
    for &vid in verts {
        let p = point(points, vid.0);
        result[0] += p[0] / verts.len() as f64;
        result[1] += p[1] / verts.len() as f64;
        result[2] += p[2] / verts.len() as f64;
    }
    Point3D::Explicit(ExplicitPoint3D { data: result })
}

#[inline(always)]
fn vert_in_tri(orientations: &[Orientation]) -> bool {
    let mut not_zero = Orientation::Undefined;
    for &ori in orientations {
        match ori {
            Orientation::Positive | Orientation::Negative => {
                if not_zero == Orientation::Undefined {
                    not_zero = ori;
                } else if not_zero != ori {
                    return false;
                }
            }
            _ => {}
        }
    }
    true
}

#[inline(always)]
fn poly_area(points: &[f64], poly: &[usize]) -> f64 {
    poly.chunks(2)
        .map(|ab| {
            let pa = &points[(ab[0] << 1)..];
            let pb = &points[(ab[1] << 1)..];
            pa[0] * pb[1] - pa[1] * pb[0]
        })
        .sum::<f64>()
}
